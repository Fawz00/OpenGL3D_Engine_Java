#version 330 core

precision highp float;

uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_MER;
uniform sampler2D TEXTURE_DEPTH;
uniform sampler2D TEXTURE_REFLECTION;
uniform sampler2D TEXTURE_LIGHTING;
uniform sampler2D TEXTURE_SSGI;

uniform mat4 MVP_MATRIX;
uniform vec2 MAIN_RESOLUTION;
uniform vec2 REFLECTION_RESOLUTION;
uniform float TIME;
uniform float gamma;
uniform float exposure;

in vec2 uv;

out vec4 FragColor;

#define USE_HDR
#define USE_BLOOM
#define USE_SSGI
#define USE_REFLECTION
#define USE_FXAA

#define PI 3.14159265358979323

vec4 getWorldPosition(float depth, vec2 uv) {
	vec4 clipSpacePosition = vec4(vec3(uv,depth)*2.0-1.0, 1.0);
	vec4 worldPosition = inverse(MVP_MATRIX)*clipSpacePosition;
	worldPosition = vec4(worldPosition.xyz/worldPosition.w, 1.0);
	return worldPosition;
}

float avg(vec4 a){
	return (a.x+a.y+a.z+a.w)/4.;
}
float avg(vec3 a){
	return (a.x+a.y+a.z)/3.;
}

vec2 rand( vec2 a, float level ){
	vec2 p = vec2( dot(a,vec2(127.1,311.7)), dot(a,vec2(269.5,183.3)) );
	vec2 random = fract(sin(p)*43758.5453);
	return (a+(random*level))-(level/2.);
}

vec4 reflectionBlur(float roughness, float depth, vec2 uv){
	float Directions = 10.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
	float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)
	float Size = 50.0; // BLUR SIZE (Radius)
	vec2 Radius = (roughness*Size/depth) /REFLECTION_RESOLUTION.xy;
	vec4 Color = texture(TEXTURE_REFLECTION, uv);
	float Pi = PI*2.;
	float counter = 1.;
	for( float d=0.0; d<Pi*2.; d+=Pi/Directions)
	{
		for(float i=1.0/Quality; i<=1.0001; i+=1.0/Quality)
		{
			vec4 colorSample = texture( TEXTURE_REFLECTION, uv+vec2(cos(d),sin(d))*Radius*i);
			if(colorSample.a>0.01 && Color.a>0.01){
				Color += colorSample;
			} else Color.a = 0.;
			counter++;
		}
	}
	Color /= counter;
	return Color;
}

vec3 fxaa(sampler2D texImage, vec2 resolution, vec2 texCoords) {
	float FXAA_SPAN_MAX = 8.0;
	float FXAA_REDUCE_MUL = 1.0/8.0;
	float FXAA_REDUCE_MIN = 1.0/128.0;

	vec3 rgbNW=texture(texImage,texCoords+(vec2(-1.0,-1.0)/resolution)).xyz;
	vec3 rgbNE=texture(texImage,texCoords+(vec2(1.0,-1.0)/resolution)).xyz;
	vec3 rgbSW=texture(texImage,texCoords+(vec2(-1.0,1.0)/resolution)).xyz;
	vec3 rgbSE=texture(texImage,texCoords+(vec2(1.0,1.0)/resolution)).xyz;
	vec3 rgbM=texture(texImage,texCoords).xyz;

	vec3 luma=vec3(0.299, 0.587, 0.214);
	float lumaNW = dot(rgbNW, luma);
	float lumaNE = dot(rgbNE, luma);
	float lumaSW = dot(rgbSW, luma);
	float lumaSE = dot(rgbSE, luma);
	float lumaM  = dot(rgbM,  luma);

	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

	vec2 dir;
	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
	dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

	float dirReduce = max(
		(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
		FXAA_REDUCE_MIN);

	float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

	dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
		  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
		  dir * rcpDirMin)) / resolution;

	vec3 rgbA = (1.0/2.0) * (
		texture(texImage, texCoords.xy + dir * (1.0/3.0 - 0.5)).xyz +
		texture(texImage, texCoords.xy + dir * (2.0/3.0 - 0.5)).xyz);
	vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
		texture(texImage, texCoords.xy + dir * (0.0/3.0 - 0.5)).xyz +
		texture(texImage, texCoords.xy + dir * (3.0/3.0 - 0.5)).xyz);
	float lumaB = dot(rgbB, luma);

	if((lumaB < lumaMin) || (lumaB > lumaMax)){
		return rgbA;
	}else{
		return rgbB;
	}
}



/*
FAST APPROXIMATION OF https://www.shadertoy.com/view/3dd3Wr

[
This project did NOT use any code from the /\ above, I was creating this
whilst comparing its visuals to the above project
]

Boi if anybody uses this script you better not change the name of the function

By: Sir Bird / Zerofile

*/

#define SAMPLES 80  // HIGHER = NICER = SLOWER
#define DISTRIBUTION_BIAS 0.6 // between 0. and 1.
#define PIXEL_MULTIPLIER  1.5 // between 1. and 3. (keep low)
#define INVERSE_HUE_TOLERANCE 20.0 // (2. - 30.)

#define GOLDEN_ANGLE 2.3999632 //3PI-sqrt(5)PI

// define pow(a,b) pow(max(a,0.),b) // @morimea

mat2 sample2D = mat2(cos(GOLDEN_ANGLE),sin(GOLDEN_ANGLE),-sin(GOLDEN_ANGLE),cos(GOLDEN_ANGLE));

vec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution) {
	vec3 denoisedColor				= vec3(0.);

	const float	sampleRadius		= sqrt(float(SAMPLES));
	const float	sampleTrueRadius	= 0.5/(sampleRadius*sampleRadius);
	vec2		samplePixel			= vec2(1.0/imageResolution.x,1.0/imageResolution.y); 
	vec3		sampleCenter		= texture(imageTexture, uv).rgb;
	vec3		sampleCenterNorm	= normalize(sampleCenter);
	float		sampleCenterSat		= length(sampleCenter);

	float  influenceSum = 0.0;
	float brightnessSum = 0.0;

	vec2 pixelRotated = vec2(0.,1.);

	for (float x = 0.0; x <= float(SAMPLES); x++) {
		pixelRotated *= sample2D;

		vec2  pixelOffset    = PIXEL_MULTIPLIER*pixelRotated*sqrt(x)*0.5;
		float pixelInfluence = 1.0-sampleTrueRadius*pow(dot(pixelOffset,pixelOffset),DISTRIBUTION_BIAS);
		pixelOffset *= samplePixel;

		vec3 thisDenoisedColor = 
			texture(imageTexture, uv + pixelOffset).rgb;

		pixelInfluence		*= pixelInfluence*pixelInfluence;
		/*
			HUE + SATURATION FILTER
		*/
		pixelInfluence		*=
			pow(0.5+0.5*dot(sampleCenterNorm,normalize(thisDenoisedColor)),INVERSE_HUE_TOLERANCE)
			* pow(1.0 - abs(length(thisDenoisedColor)-length(sampleCenterSat)),8.);

		influenceSum += pixelInfluence;
		denoisedColor += thisDenoisedColor*pixelInfluence;
	}

	return denoisedColor/influenceSum;
}

void main() {
//	vec4 color = vec4(sirBirdDenoise(TEXTURE_0, uv, MAIN_RESOLUTION/4.0),1.0);
	vec4 color = texture(TEXTURE_0, uv);
	
	#if USE_FXAA > 0
		color.rgb = fxaa(TEXTURE_0, MAIN_RESOLUTION, uv);
	#endif

	vec4 position = getWorldPosition(texture(TEXTURE_DEPTH, uv).r, uv);
	vec3 view = vec4( MVP_MATRIX * position ).xyz;
	float depth = 10.0; // view.z;
	float roughness = texture(TEXTURE_MER,uv).b*5.0;

	// SSGI
	#if USE_SSGI
		vec3 ssgi = vec3(0.0);
		for(float y=-1.0; y<=1.0; y++) for(float x=-1.0; x<=1.0; x++){
			ssgi += (
						textureLod(TEXTURE_SSGI, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/8.0)), 3).rgb+
						textureLod(TEXTURE_SSGI, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/4.0)), 2).rgb+
						textureLod(TEXTURE_SSGI, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/2.0)), 1).rgb)/3.0;
		}
		ssgi /= 4.5;
		color.rgb += ssgi;
	#endif

	// SCREEN SPACE REFLECTION
	#if USE_REFLECTION == 1
		if(texture(TEXTURE_MER,uv).r > 0.125){
	//		vec4 reflection = reflectionBlur(roughness, depth, uv);
	//		vec4 reflection = reflectionBlur(roughness, depth, rand(uv, roughness*0.05/depth));
			vec4 reflection = texture(TEXTURE_REFLECTION, uv);

			color.rgb = mix(color.rgb, reflection.rgb, texture(TEXTURE_MER,uv).r*((reflection.r+reflection.g+reflection.b)/3.)*reflection.a);
		}
	#endif

	// HDR & GAMMA
	#if USE_HDR
        // reinhard
        // vec3 result = color.rgb / (color.rgb + vec3(1.0));
        // exposure
        vec3 result = vec3(1.0) - exp(-color.rgb * exposure);
        // also gamma correct while we're at it
		result = pow(color.rgb, vec3(1.0 / gamma));
		color.rgb = result;
    #else
		color.rgb = pow(color.rgb, vec3(1.0 / gamma));
	#endif

	// BLOOM
	#if USE_BLOOM
		vec3 bloom = vec3(0.0);
		for(float y=-1.0; y<=1.0; y++) for(float x=-1.0; x<=1.0; x++){
			bloom += (
						textureLod(TEXTURE_LIGHTING, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/32.0)), 5).rgb+
						textureLod(TEXTURE_LIGHTING, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/16.0)), 4).rgb+
						textureLod(TEXTURE_LIGHTING, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/8.0)), 3).rgb+
						textureLod(TEXTURE_LIGHTING, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/4.0)), 2).rgb+
						textureLod(TEXTURE_LIGHTING, uv+((vec2(x,y)+vec2(0.5, 0.0)) / (MAIN_RESOLUTION/2.0)), 1).rgb)/5.0;
		}
		bloom /= 4.5;
		color.rgb += bloom;
	#endif

 color.rgb = texture(TEXTURE_SSGI, uv).rgb;
//	vec2 ap = uv - 0.5;
//	if(ap.x>0.0 && ap.y>0.0) color.rgb += 0.1;

	FragColor = color;
}