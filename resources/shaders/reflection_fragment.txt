#version 330 core

precision highp float;

uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_MER;
uniform sampler2D TEXTURE_DEPTH;
uniform sampler2D TEXTURE_NORMAL;

uniform mat4 ROTATION_MATRIX;
uniform mat4 PROJECTION_MATRIX;
uniform vec2 RESOLUTION;

in vec2 uv;

layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 FragMer;

struct reflectedSurface {
	vec4 color;
	vec3 mer;
};

bool rayIsOutofScreen(vec2 ray){
	return (ray.x > 1 || ray.y > 1 || ray.x < 0 || ray.y < 0) ? true : false;
}

float linstep(float a, float b, float x){
    return clamp((x - a)/(b - a), 0., 1.); 
}

const float edgeFadeWidth = 0.075;
reflectedSurface TraceRay(vec3 rayPos, vec3 dir, int iterationCount){
	float sampleDepth;
	reflectedSurface hitColor;
	float rayDistance = 0.;
	vec3 startPos = rayPos;
	bool hit = false;

	for(int i = 0; i < iterationCount; i++){
		rayPos += dir;
		rayDistance = distance(startPos, rayPos);
		if(rayIsOutofScreen(rayPos.xy)){
			break;
		}

		sampleDepth = texture(TEXTURE_DEPTH, rayPos.xy).r;
		float depthDif = rayPos.z - sampleDepth;
		if(depthDif >= 0.0 && depthDif < 0.0001 && rayDistance > 0.0001){ //we have a hit
			hit = true;

			vec2 d = abs(rayPos.xy - 0.5);
            float mult = max(d.x, d.y);
            float edgeFade = linstep(0.5, 0.5 - max(edgeFadeWidth,0.01), mult);

			hitColor.color.rgb = texture(TEXTURE_0, rayPos.xy).rgb;//*pow(texture(TEXTURE_MER, rayPos.xy).g+1.0, 3.0);
			hitColor.color.a = edgeFade;
			hitColor.mer = texture(TEXTURE_MER, rayPos.xy).rgb;
			break;
		}
	}
	return hitColor;
}

void main() {
	vec4 color = vec4(0.,0.,0.,1.);
	vec3 mer = vec3(0.);

	// SCREEN SPACE REFLECTION
	if(texture(TEXTURE_MER, uv).r >= 0.125) {
		float maxRayDistance = 50.0f;

		//View Space ray calculation
		vec3 pixelPositionTexture;
		pixelPositionTexture.xy = uv;
		vec4 normalView = texture(TEXTURE_NORMAL, pixelPositionTexture.xy);
		normalView.g = 1.-normalView.g;
		normalView.rgb = normalView.rgb*2.-1.;
		normalView = ROTATION_MATRIX*normalView;
		float pixelDepth = texture(TEXTURE_DEPTH, pixelPositionTexture.xy).r;
		pixelPositionTexture.z = pixelDepth;
		vec4 positionView = inverse(PROJECTION_MATRIX) * vec4(pixelPositionTexture * 2. - vec3(1.), 1.);
		positionView /= positionView.w;
		vec3 reflectionView = reflect(-positionView.xyz, normalize(normalView.xyz));
		if(reflectionView.z < 0){
			color = vec4(0.0);
			mer = vec3(0.0);
			return;
		}
		vec3 rayEndPositionView = positionView.xyz + reflectionView * maxRayDistance;


		//Texture Space ray calculation
		vec4 rayEndPositionTexture = PROJECTION_MATRIX * vec4(rayEndPositionView,1.);
		rayEndPositionTexture /= rayEndPositionTexture.w;
		rayEndPositionTexture.xyz = (rayEndPositionTexture.xyz + vec3(1.)) / 2.0f;
		vec3 rayDirectionTexture = rayEndPositionTexture.xyz - pixelPositionTexture;

		ivec2 screenSpaceStartPosition = ivec2(pixelPositionTexture.x * RESOLUTION.x, pixelPositionTexture.y * RESOLUTION.y); 
		ivec2 screenSpaceEndPosition = ivec2(rayEndPositionTexture.x * RESOLUTION.x, rayEndPositionTexture.y * RESOLUTION.y); 
		ivec2 screenSpaceDistance = screenSpaceEndPosition - screenSpaceStartPosition;
		int screenSpaceMaxDistance = max(abs(screenSpaceDistance.x), abs(screenSpaceDistance.y)) / 2;
		rayDirectionTexture /= max(screenSpaceMaxDistance, 0.001f);

		//trace the ray
		reflectedSurface colorData = TraceRay(pixelPositionTexture, rayDirectionTexture, screenSpaceMaxDistance);
		color = colorData.color;
		mer = colorData.mer;
	}
	//color.rgb = texture(TEXTURE_DEPTH, uv.xy).rgb;

	FragColor = color;
	FragMer = vec4(mer, 1.0);
}