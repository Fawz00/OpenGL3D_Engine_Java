#version 330 core

precision highp float;

#define USE_SHADOW
#define USE_PENUMBRA_SHADOW
#define USE_NORMAL_MAP
#define USE_PARALLAX

uniform sampler2D TEXTURE;
uniform sampler2D TEXTURE_NORMAL;
uniform sampler2D TEXTURE_PARALLAX;
uniform sampler2D TEXTURE_MER;
uniform sampler2D DEPTH_MAP;

uniform float USE_NORMAL_TEXTURE;
uniform float USE_PARALLAX_TEXTURE;
uniform float USE_MER_TEXTURE;

uniform float TIME;
uniform float DAYLIGHT;
uniform vec3 SUN_DIR;
uniform float SHADOW_SIZE;
uniform float SHADOW_RESOLUTION;
uniform float INSTANCED;

in vec2 uv;
in vec4 position;
in vec4 vPos;
in vec4 shadowView;
in vec3 dNormal;

in vec3 shadowViewPosition;
in vec3 viewPosition;

in vec3 tangentShadowViewPosition;
in vec3 tangentPosition;
in vec3 tangentViewPosition;

layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 FragDepth;
layout (location = 2) out vec4 FragMer;
layout (location = 3) out vec4 FragNormal;

//define SHADOW_COLOR vec3(0.25098039215, 0.61176470588, 1.0)
#define SHADOW_COLOR vec3(0.4, 0.701960784313, 1.0)/8.0
//define SHADOW_COLOR vec3(0.4, 0.701960784313, 1.0)
#define DISPLACEMENT_HEIGHT_SCALE 0.015

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir) {
	const float minLayers = 8;
	const float maxLayers = 24;
	float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));  

	float layerDepth = 1.0 / numLayers;
	float currentLayerDepth = 0.0;
	vec2 P = viewDir.xy / viewDir.z * DISPLACEMENT_HEIGHT_SCALE; 
	vec2 deltaTexCoords = P / numLayers;

	vec2  currentTexCoords     = fract(texCoords);
	float currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;

	int a = 0;
	while(currentLayerDepth < currentDepthMapValue && a<16) {
		currentTexCoords -= deltaTexCoords;
		currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;  
		currentLayerDepth += layerDepth;
		a++;
	}
	
	vec2 prevTexCoords = currentTexCoords + deltaTexCoords;

	float afterDepth  = currentDepthMapValue - currentLayerDepth;
	float beforeDepth = texture(TEXTURE_PARALLAX, prevTexCoords).r - currentLayerDepth + layerDepth;
 
	float weight = afterDepth / (afterDepth - beforeDepth);
	vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);

	return finalTexCoords;
}
float ParallaxShadow(vec2 texCoord, vec3 lightDir) {
	if ( lightDir.z <= 0.0 ) return 0.0;

	float minLayers = 12;
	float maxLayers = 32;
	float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), lightDir)));

	vec2 currentTexCoords = texCoord;
	float currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;
	float currentLayerDepth = currentDepthMapValue;

	float layerDepth = 1.0 / numLayers;
	vec2 P = lightDir.xy / lightDir.z * DISPLACEMENT_HEIGHT_SCALE;
	vec2 deltaTexCoords = P / numLayers;

	while (currentLayerDepth <= currentDepthMapValue && currentLayerDepth > 0.0)
	{
		currentTexCoords += deltaTexCoords;
		currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;
		currentLayerDepth -= layerDepth;
	}

	float r = currentLayerDepth > currentDepthMapValue ? 0.0 : 1.0;
	//float r = currentLayerDepth > 0.0 ? 0.0 : 1.0;

	return r;
}
float ParallaxDepth(vec2 texCoord, vec3 viewDir) {
	if ( viewDir.z <= 0.0 ) return 0.0;

	float minLayers = 12;
	float maxLayers = 64;
	float numLayers = mix(maxLayers, minLayers, abs(dot(vec3(0.0, 0.0, 1.0), viewDir)));

	vec2 currentTexCoords = texCoord;
	float currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;
	float currentLayerDepth = currentDepthMapValue;

	float layerDepth = 1.0 / numLayers;
	vec2 P = viewDir.xy / viewDir.z * DISPLACEMENT_HEIGHT_SCALE;
	vec2 deltaTexCoords = P / numLayers;

	while (currentLayerDepth <= currentDepthMapValue && currentLayerDepth > 0.0)
	{
		currentTexCoords += deltaTexCoords;
		currentDepthMapValue = texture(TEXTURE_PARALLAX, currentTexCoords).r;
		currentLayerDepth -= layerDepth;
	}

	float r = currentLayerDepth > currentDepthMapValue ? 0.0 : 1.0;
	return currentLayerDepth;
}

mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv ){
	vec3 dp1 = dFdx(p);
	vec3 dp2 = dFdy(p);
	vec2 duv1 = dFdx(uv);
	vec2 duv2 = dFdy(uv);

	vec3 dp2perp = cross(dp2, N);
	vec3 dp1perp = cross(N, dp1);
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

	float invmax = inversesqrt(max(dot(T,T), dot(B,B)));
	return mat3(T*invmax, B*invmax, N);
}
vec3 petrub_normal(vec3 N, vec3 V, vec2 texcoord){
	vec3 map = vec3(0.,0.,1.);
	if(USE_NORMAL_TEXTURE == 1.0 && USE_NORMAL_MAP == 1){
		map = texture(TEXTURE_NORMAL, texcoord).rgb;
		map.r = 1.0 - map.r;
		map = map * 255./127. - 128./127.;
	}
	mat3 TBN = cotangent_frame(N, -V, texcoord);
	return normalize(TBN*map);
}

vec2 rand(vec2 a){
	a = vec2(dot(a,vec2(127.1,311.7)), dot(a,vec2(269.5,183.3)));
	return fract(sin(a)*43758.5453);
}



//========================================//
//          M A I N   F U N C T I O N     //
//========================================//
void main() {
	vec3 ambient = vec3(1.4, 1.28, 1.24);
	vec3 normal;
	vec2 texCoords = uv;
	vec3 lightColor = mix(vec3(1.0, 0.5294117647, 0.21176470588), vec3(1.0, 1.0, 0.98431372549), clamp(sqrt(SUN_DIR.y), 0.0, 1.0));

	vec3 MetallicEmitnessRoughness = vec3(0.25, 0.0, 0.5);
	if(USE_MER_TEXTURE == 1.0) MetallicEmitnessRoughness = texture(TEXTURE_MER, texCoords).rgb;



	vec3 viewDir = normalize(viewPosition - position.xyz);
	vec3 lightDir = normalize(shadowViewPosition);

	vec3 tangentViewDir = normalize(tangentViewPosition - tangentPosition);
	vec3 tangentLightDir = normalize(tangentShadowViewPosition);

	if(USE_PARALLAX_TEXTURE == 1.0 && USE_PARALLAX == 1){
		texCoords = ParallaxMapping(uv, tangentViewDir);
		if(texCoords.x > 1.0 || texCoords.y > 1.0 || texCoords.x < 0.0 || texCoords.y < 0.0) discard;
	}

	normal = petrub_normal(dNormal, viewDir, texCoords);


	//diffuse
	float diff = max(dot(lightDir, normal), 0.0);
	vec4 diffuse = texture(TEXTURE, texCoords);

	if(diffuse.a < 0.1) discard;

	// specular
	vec3 reflectDir = reflect(-lightDir, normal);
	vec3 halfwayDir = normalize(lightDir + viewDir);
	float specPow = 32.0;

	if(USE_MER_TEXTURE == 1.0) specPow /= texture(TEXTURE_MER, texCoords).b;

	float spec = pow(max(dot(normal, halfwayDir), 0.0), specPow);
	if (USE_MER_TEXTURE == 1.0){
		spec *= texture(TEXTURE_MER, texCoords).r;
	} else spec *= 0.85;
	MetallicEmitnessRoughness.b = max(spec, MetallicEmitnessRoughness.g);

	float shadow = 1.0;
	#if (USE_SHADOW == 1)
		float depthTest;
		float shadowDepthOffset = 1.7320508075688/SHADOW_RESOLUTION;
		vec2 shadowProj = (shadowView.xy+1.0)/2.0;
		float shadowTexture = texture(DEPTH_MAP, shadowProj).r;
		depthTest = ((shadowView.z/shadowView.w)+1.0)/2.0;

		#if (USE_PENUMBRA_SHADOW == 1)
			float smoothShadow;
			float shadowDist = 1.0;
			float shadowPcf = 3.0;
			float shadowPcfPoints = (shadowPcf*2.0+1.0)*(shadowPcf*2.0+1.0);
			float fixedShadowMulti = SHADOW_RESOLUTION*16.0;
			vec2 fixedShadowProj = floor(shadowProj*fixedShadowMulti)/fixedShadowMulti;

			for(float y=-1.0; y<=1.0; y++) for(float x=-1.0; x<=1.0; x++){
				float ShadowTex = texture( DEPTH_MAP, shadowProj+((vec2(x,y)*0.5)/SHADOW_SIZE) ).r;
				shadowDist = min(shadowDist, ShadowTex);
			}
			if(shadowDist > 0.0){
				float a = depthTest-shadowDist;
				float b = depthTest-shadowTexture;
				float shdDst = min(a,b);
				if(shdDst < 0.009765625) shdDst = a;
				shdDst = clamp(shdDst*2.0, 0.0, 1.0)*0.025625;

				for(float y=-shadowPcf; y<=shadowPcf; y++) for(float x=-shadowPcf; x<=shadowPcf; x++){
					vec2 offset = fixedShadowProj - (vec2(x,y)/fixedShadowMulti);
					smoothShadow = texture( DEPTH_MAP, (shdDst*(rand(offset)-0.5)) + offset ).r;
					if(smoothShadow+shadowDepthOffset < depthTest) shadow -= 1.0/shadowPcfPoints;
				}
			}else{
				smoothShadow = shadowTexture;
				if(smoothShadow+shadowDepthOffset < depthTest) shadow = 0.0;
			}
		#else
			if(shadowTexture+shadowDepthOffset < depthTest) shadow = 0.0;
		#endif

		if(shadowProj.x > 1.0 || shadowProj.x < 0.0 ||
			shadowProj.y > 1.0 || shadowProj.y < 0.0 ||
			depthTest > 1.0 || depthTest < 0.0) shadow = 1.0;
		if(USE_PARALLAX_TEXTURE == 1.0 && USE_PARALLAX == 1) shadow = min( shadow, ParallaxShadow(texCoords, normalize(tangentLightDir)) );
		shadow = clamp(pow(DAYLIGHT, 0.5)*min(diff, shadow), 0.0, 1.0);
		diffuse.rgb *= mix(SHADOW_COLOR*0.725, lightColor, max(shadow, MetallicEmitnessRoughness.g*2.0));
		diffuse.rgb += mix(vec3(0.0), vec3(spec*lightColor), shadow);
//		diffuse.rgb = vec3(shadowProj,0.0);
	#else
		// vec3 shading = vec3(clamp(diff, 0.34, 2.0)*ambient);
		// diffuse.rgb = (diffuse.rgb*shading)+(lightColor*spec);

		shadow = clamp(pow(DAYLIGHT, 0.5)*min(diff, shadow), 0.0, 1.0);
		diffuse.rgb *= mix(SHADOW_COLOR*0.725, lightColor, max(shadow, MetallicEmitnessRoughness.g*2.0));
		diffuse.rgb += mix(vec3(0.0), vec3(spec*lightColor), shadow);
	#endif

	//diffuse.rgb = mix(0.0*diffuse.rgb+ambient, diffuse.rgb+ambient+spec, shadow);

	FragColor = diffuse;
	FragDepth = vec4(gl_FragCoord.z, vPos.z, 0.0, 1.0);
//	FragDepth.rgb = vec3(ParallaxDepth(texCoords, tangentLightDir));
	FragMer = vec4(MetallicEmitnessRoughness, 1.0);
	FragNormal = vec4((normalize(normal)+1.)/2., 1.0);
}