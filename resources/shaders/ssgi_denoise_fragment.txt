#version 330 core

uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_1;
uniform sampler2D TEXTURE_NORMAL;
uniform sampler2D TEXTURE_DEPTH;
uniform sampler2D TEXTURE_LIGHT;

uniform vec4 VIEW_POSITION;
uniform vec2 RESOLUTION;
uniform float FOV;

in vec2 uv;
out vec4 FragColor;

//Source: https://www.shadertoy.com/view/fddfDX

//Screen Space GI pass
//
//Heavily Modified/Simplied/Partially re-written version of SSGI by Alexander Sannikov from "Legit Engine"
//
//Alexander Sannikov
//MIT License
//https://github.com/Raikiri/LegitEngine
//

const float kSize1 = 4.0;
const float jank = 1.5;
vec3 fragCamPos = vec3(0);
mat3 getCamMatrix(vec3 ro, vec3 look) {
    vec3 f = normalize(ro - look);
    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f)); 
    return mat3(-r, normalize(cross(f, r)), -f);
}

vec3 screenToWorld(vec3 screenPos)
{
  screenPos.xy -= 0.5;
  screenPos.xy /= vec2(RESOLUTION.y / RESOLUTION.x, 1);
  vec3 ro = fragCamPos;
  mat3 camMat = getCamMatrix(ro,vec3(0.0));
  vec3 rd = camMat*normalize(vec3(screenPos.xy , 1./FOV)); 
  return ro + screenPos.z*rd;
}

//Denoise is weighted based on worldspace distance and alignment of normals
vec3 edgeDenoise(vec2 fragCoord)
{
    vec2 uv = fragCoord / RESOLUTION.xy;
    vec3 fragNormal = texture(TEXTURE_NORMAL, uv).rgb;
    float fragDepth = texture(TEXTURE_DEPTH, uv).g;
    vec3 fragPos = screenToWorld(vec3(uv, fragDepth));
    float weight = 0.0;
    vec3 col = vec3(0);
    float kSize = kSize1;
    for(float i = -kSize; i <=kSize; i++){
        for(float j = -kSize; j <=kSize; j++){
            vec2 sampleUV = (fragCoord + vec2(i,j)*jank)/RESOLUTION.xy;
            vec3 sampleNorm = texture(TEXTURE_NORMAL, sampleUV).rgb;
            float sampleDepth = texture(TEXTURE_DEPTH, sampleUV).g;
            vec3 samplePos = screenToWorld(vec3(sampleUV, sampleDepth));
            float normAlignment = clamp(dot(sampleNorm, fragNormal), 0.0, 1.0);
            float delta = distance(samplePos, fragPos) * 0.1;
            vec3 sampleCol = texture(TEXTURE_1, sampleUV).rgb;
            float sampleWeight = normAlignment / (delta + 1e-2);
            weight += sampleWeight;
            col += sampleCol * sampleWeight;
        }
    }
    return col/weight; 
}

void main() {
    fragCamPos = VIEW_POSITION.xyz;
	vec3 color = (edgeDenoise(gl_FragCoord.xy)+texture(TEXTURE_0, uv).rgb)/2.0;

	FragColor = vec4(clamp(color,vec3(0.0),vec3(1.0)), 1.0);
}